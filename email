import groovy.json.JsonSlurper
import jenkins.model.*
import com.cloudbees.plugins.credentials.*
import com.cloudbees.plugins.credentials.domains.*
import com.cloudbees.plugins.credentials.impl.*
import hudson.util.*

/*
  MotioCI CLI Dynamic Project Loader with Full Debugging
  ------------------------------------------------------
  This version avoids File.bytes (uses OutputStream)
  and prints detailed output for each step.
*/

// ===== CONFIGURATION =====
def MOTIO_SERVER = "https://cgrptmcip01.cloud.cammis.ca.gov"
def SOURCE_ENV   = SOURCE_ENV ?: "Cognos-DEV/TEST"
def WORKSPACE    = "/var/lib/jenkins/combined-devops-cognos-deployments/MotioCI/api/CLI"
def PYTHON       = "python3"
def CRED_ID      = "cognos-credentials"
// ==========================

def results = []
def TOKEN = ""

try {
    // --- Step 1Ô∏è‚É£ Look up Jenkins Credential ---
    results << "üîç Step1: Looking up Jenkins credential '${CRED_ID}'..."
    def j = Jenkins.getInstance()
    def credsList = j.getExtensionList('com.cloudbees.plugins.credentials.SystemCredentialsProvider')[0]
    def allCreds = credsList.getStore().getCredentials(Domain.global())
    def cred = allCreds.find { it.id == CRED_ID }

    if (!cred) {
        results << "‚ùå Step1: Credential '${CRED_ID}' not found!"
        return results
    }
    results << "‚úÖ Step1: Credential located successfully."

    // --- Step 2Ô∏è‚É£ Write credential content to temp file ---
    def tmpCredFile = File.createTempFile("motio-cred-", ".json")
    tmpCredFile.deleteOnExit()
    def fos = new FileOutputStream(tmpCredFile)
    fos.write(cred.getContent())
    fos.close()
    results << "‚úÖ Step2: Temporary credentials.json created at ${tmpCredFile.absolutePath}"

    // --- Step 3Ô∏è‚É£ Verify CLI path ---
    def cliFile = new File("${WORKSPACE}/ci-cli.py")
    if (!cliFile.exists()) {
        results << "‚ùå Step3: CLI file not found at ${cliFile.absolutePath}"
        tmpCredFile.delete()
        return results
    }
    results << "‚úÖ Step3: CLI located successfully at ${cliFile.absolutePath}"

    // --- Step 4Ô∏è‚É£ Run login command ---
    results << "üîç Step4: Running login command..."
    def loginCmd = [
        "bash", "-c",
        """
        cd ${WORKSPACE} &&
        ${PYTHON} ci-cli.py --server=${MOTIO_SERVER} \
          login --credentialsFile ${tmpCredFile.absolutePath}
        """
    ]
    results << "üß† Executing: ${loginCmd.join(' ')}"

    def loginProc = loginCmd.execute()
    def loginOut = new StringBuffer()
    def loginErr = new StringBuffer()
    loginProc.consumeProcessOutput(loginOut, loginErr)
    loginProc.waitFor()

    results << "üîπ Login STDOUT:\n${loginOut.toString()}"
    results << "üîπ Login STDERR:\n${loginErr.toString()}"

    TOKEN = loginOut.toString().find(/[A-Za-z0-9._-]{20,}/)
    if (!TOKEN || TOKEN.length() < 10) {
        results << "‚ùå Step4: Login failed ‚Äî token not found!"
        tmpCredFile.delete()
        return results
    }
    results << "‚úÖ Step4: Token retrieved successfully (${TOKEN.take(10)}...)"

    // --- Step 5Ô∏è‚É£ Run project listing ---
    results << "üîç Step5: Fetching projects..."
    def listCmd = [
        "bash", "-c",
        """
        cd ${WORKSPACE} &&
        ${PYTHON} ci-cli.py --server=${MOTIO_SERVER} \
          project ls --xauthtoken ${TOKEN} \
          --instanceName ${SOURCE_ENV}
        """
    ]
    results << "üß† Executing: ${listCmd.join(' ')}"

    def listProc = listCmd.execute()
    def listOut = new StringBuffer()
    def listErr = new StringBuffer()
    listProc.consumeProcessOutput(listOut, listErr)
    listProc.waitFor()

    def raw = listOut.toString().trim()
    results << "üîπ CLI STDOUT (first 400 chars):\n${raw.take(400)}"
    results << "üîπ CLI STDERR:\n${listErr.toString()}"

    if (!raw) {
        results << "‚ö†Ô∏è Step5: CLI returned empty output ‚Äî token or env invalid?"
        tmpCredFile.delete()
        return results
    }

    // --- Step 6Ô∏è‚É£ Parse JSON response ---
    try {
        results << "üîç Step6: Parsing JSON output..."
        def json = new JsonSlurper().parseText(raw)
        def edges = json?.data?.instances?.edges ?: []
        def projects = []
        edges.each { e ->
            e?.node?.projects?.edges?.each { p ->
                def name = p?.node?.name
                if (name) projects << name
            }
        }

        if (projects.isEmpty()) {
            results << "‚ö†Ô∏è Step6: JSON parsed but no projects found."
        } else {
            results << "‚úÖ Step6: Parsed successfully ‚Äî ${projects.size()} projects found."
            results.addAll(projects.unique().sort())
        }
    } catch (Exception pe) {
        results << "‚ùå Step6: JSON parsing error ‚Äî ${pe.message}"
        results << "‚ö†Ô∏è Raw JSON:\n${raw.take(500)}"
    }

    tmpCredFile.delete()
    results << "‚úÖ Cleanup complete: Temporary credentials removed."
    return results

} catch (Exception e) {
    return ["‚ùå Unexpected error: ${e.message}", e.toString()]
}
